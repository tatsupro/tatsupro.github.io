# DevOps

**Nó từng là một từ có ý nghĩa còn giờ thì không.** Đọc định nghĩa sai tại [Wikipedia.org](https://en.wikipedia.org/wiki/DevOps).

_Vì không quan trọng bạn hiểu đúng hoặc sai, hay thậm chí không hiểu gì cả. <u>Mà bạn cần biết mình làm gì</u>._ Sau đây là danh sách những công cụ hoặc luồng làm việc cần biết để sử dụng và quản lý:

1. **Phần cứng máy tính** và [**Cloud**](/cloud/index.md), phần cứng chỉ cần biết các thành phần cơ bản và các dịch vụ điện toán đám mây (của AWS, Google hoặc Azure) hay được sử dụng trong thực tế. Sau khi hiểu rõ hơn rồi thì có thể tìm hiểu thêm về tool IaC (Infrastructure as Code) như [**Terraform**](/terraform/index.md).
2. **Hệ điều hành (OS)** là thứ kể cả người học tin học phổ thông tuy chưa bao giờ hiểu sâu về nó nhưng cũng nghe qua về cái tên (chắc vậy). Một khi đã đâm đầu sang phía Infra thì cũng nên hiểu cách dùng hệ điều hành hơn chút để biết thêm một số chương trình có sẵn. Hệ điều hành hay dùng có thể kể đến như:
   - **Microsoft Windows** có thể là OS nên cài trên máy tính cá nhân nếu bạn có một cuộc đời, nhưng nếu nó ở trên server thì có vẻ như công ty bạn đang làm đang là nô lệ hệ sinh thái của Microsoft và đến lúc này bạn nên ước mình chưa từng sinh ra trên cuộc đời này. Vì mọi thứ đều rất Microsofty từ command line cho tới những phần mềm tệ hại mà giới lập trình viên quay lưng không muốn quan tâm.
   - Tiếp theo là vế còn lại của thế giới hay dùng là **các OS thuộc gia đình Unix**: thủy tổ của họ nhà này là bản Unix được phát triển ở AT&T Bell Labs (nơi có Ken Thompson and Dennis Ritchie đóng góp cho công cuộc đẻ ra rất nhiều phần mềm kino sau này) với phiên bản thương mại đầu tiên là <u>System V</u>. Bối cảnh Unix được tạo ra là khi OS trước đó chỉ <u>chạy đơn nhiệm với 1 người dùng</u> như họ nhà DOS chỉ đủ để <u>thực hiện một số thao tác cơ bản</u> và lập trình bằng BASIC mà tới thời điểm này (cuối năm 1960s) mainframe cũng đã bắt đầu sẵn sàng cho các tác vụ nặng hơn, vậy nên Unix ra đời với <u>khả năng đa nhiệm - nhiều người dùng</u>... và cũng cùng với sự ra đời của ngôn ngữ C tích hợp chung với Unix. Ở thời điểm mới ra mắt thì Unix bị đánh giá là tốn kém tài nguyên sử dụng nhưng nhiều năm sau đó thì đây không còn là vấn đề nữa rồi. Thành công của <u>System V</u> tốt tới mức Đại học Berkeley ăn cắp đống code đó và làm một bản Unix riêng của mình có tên là **BSD** (Berkeley Software Distribution) và dẫn tới nhiều vụ kiện và đấu đá mà người ta còn gọi đó là Unix Wars - Sau này khi cuộc chiến ngã ngũ thì BSD vẫn là một OS nhưng source code cũng đã khác nhiều so với Unix (mặc dù qua cách sử dụng thì mọi thứ vẫn gần như tương tự). Trong thời điểm này, việc BSD phân phối lại cũng truyền cảm hứng cho một thế hệ đấu tranh cho phần mềm mở và làm Unix dễ dàng tiếp cận với giới sinh viên và sở thích theo học thay vì để Unix độc quyền trong tay của AT&T và tạo ra một loạt hệ điều hành tương tự Unix như <u>MIMIX</u> và sau đó truyền cảm hứng cho **Linux**. Qua lịch sử được sơ lược qua của Unix thì tất cả những gì được để lại tới ngày nay là:
     - [**Linux**](/linux/index.md) là OS mà nếu bạn cài trên PC thì bạn không có một cuộc đời, nhưng ở thập niên 2000s thì hầu như mọi server nên chạy bằng Linux chứ đừng dùng Windows. Cái tên Linux ban đầu chỉ để đặt cho phần quan trọng nhất của hệ điều hành là <u>kernel</u> và khó có khả năng sử dụng nếu đứng một mình, để có chức năng của một OS đầy đủ như Windows thì nó cần <u>GNU coreutils</u>, các thành phần giao diện đồ họa và chương trình người dùng khác thì mới có chức năng đầy đủ. Lý do phần này được đề cập cụ thể tới mức này là để hiểu rằng thứ mà gọi là Linux được cấu tạo bởi nhiều thành phần và có khả năng thay thế được và tùy theo từng bản Linux (như <u>Ubuntu, Debian, Red Hat, Open SUSE Arch Linux, v.v.</u>) thường sẽ gần như giống nhau và không có gì khác biệt hoặc khác biệt hoàn toàn, ví dụ như Alpine Linux là bản Linux mà sử dụng <u>Busybox</u> thay cho GNU coreutils cho mục đích tối giản. **_Sau cùng dù có nhiều bản nhưng tất cả đều là Linux_**, chỉ là được tùy chỉnh cho nhiều mục đích khác nhau.
     - **Họ nhà BSD** không giống như Linux vốn bị ràng buộc bởi rất nhiều quy tắc và định hướng sai lệch thì các OS họ nhà BSD thường được phát triển theo định hướng kỹ thuật tốt hơn nên chúng có ưu điểm là đơn giản và bảo mật hơn. Các OS phổ biến của họ nhà này có thể kể đến như OpenBSD, FreeBSD, NetBSD, v.v. **MacOS** là một bản phân phối lại của FreeBSD nên các chương trình và dòng lệnh tương tự - và đây là lý do một lượng lớn người làm IT chọn Mac vì nó đơn giản với người dùng phổ thông nhưng vẫn có tinh hoa của Unix. Tất nhiên không có thứ gì hoàn hảo và nhất là sản phẩm làm bởi Apple luôn đóng cửa và thích chơi trong vườn của mình, quan trọng hơn là người tạo ra nhiều thiết kế ngu xuẩn mà tôi không thể stand được: tao đang nhìn mày đấy _trình quản lý cửa sổ_ và những gì Apple làm vừa là điều tuyệt vời nhưng cũng là điều tệ hại nhất từng xảy ra trong lịch sử ngành điện toán.
3. [**Mạng máy tính**](/network/index.md) là kiến thức nền tảng trong thời buổi mà Internet phát triển như bây giờ, không cần nắm quá sâu mà chỉ cần hiểu sơ về: mô hình mạng như OSI (Open Systems Interconnection); các giao thức hoặc thành phần mạng như TCP hoặc UDP, HTTP/HTTPS, DNS, SSH, FTP/SFTP, v.v. Mã hóa kết nối như SSL/TLS và tương tự. Các phương thức Routing như Robin, Service Mesh, v.v.
4. [**Lập trình** (tùy chọn):](/programming/index.md) Không cần phải biết quá nhiều cũng nên nắm sơ qua để hiểu cách thức ngôn ngữ đó vận hành hoặc biết viết chút ít để viết tool hoặc script tự động hóa vài thứ. Sau đây là một số gợi ý và đường dẫn tới các ngôn ngữ lập trình nên biết để sử dụng:
   - [**Python**](/programming/python.md) là lựa chọn tối ưu cho mọi người vì hiếm khi DevOps động tới code và đây là ngôn ngữ rất đơn giản và dễ học, ứng dụng ở nhiều thứ khác nhau. Biết viết chút ít python cũng đỡ đi nhiều việc tay chân mỗi ngày.
   - **Shell Script** và lý do vì mục thứ 2: Unix (nó là một phần của OS) và [GitLab](/git/gitlab.md).
   - [**Go**](/programming/go.md) (hay Golang) là lựa chọn bạn không cần phải học nhưng cũng hay nếu biết được thì có thể dùng để viết một số tool phục vụ cho luồng làm việc.
   - Và gợi ý cuối cùng thuộc diện động vào cái gì tìm hiểu cái đó là [Java](/programming/java.md) và [JavaScript](/programming/javascript.md). Lý do đơn giản là vì chúng được sử dụng rộng rãi ở khắp mọi nơi, tuy bạn có thể không chuyên sâu vào dev nhưng một khi vào cái ngành chết tiệt này thì dù có muốn né tránh cỡ nào đi chăng nữa thì ở thời điểm nào đó trong cuộc đời bạn cũng phải động tới 1 trong 2 thứ này. Hiểu chúng nó để biết được cách thức vận hành ra sao.
5. **Text Editor** như [**Visual Studio Code**](/tools/vscodium.md) hoặc [**Vim**](/tools/neovim.md). Với công việc hằng ngày của DevOps thì không phải ngồi cả ngày với Text Editor nên khuyên khích dùng VSCode hơn, nhưng với một số trường hợp khi remote tới một server mà không có GUI thì việc cần và sử dụng một TUI lighweight như Vim hoặc Nano là cần thiết. Cái này là tùy chọn ở mỗi người, miễn sao dùng cái nào để làm được việc là được.
6. [**Git**](/git/index.md) (VCS) dùng để quản lý code và **GitHub** hoặc [**GitLab**](/git/gitlab.md) để làm một nơi lưu trữ code (thường là trên Cloud), collab với người khác và automate luồng CI/CD. Có nhiều VCS khác nhưng ai quan tâm chứ? Trừ khi bạn làm việc ở big tech thì họ có nhiều lựa chọn tốt hơn _phải học_.
7. [**Container**](/container/index.md) là công nghệ thịnh hành từ 2015 trở đi, với cá nhân từ một người làm infra thì nó không có quá nhiều khác biệt so với việc setup máy ảo nếu nói về thành phẩm cuối cùng. Yếu tố làm container nên học ở thời điểm này là vì nhiều doanh nghiệp đang chuyển sang sử dụng nó, trong giới này có một câu "Không ai mất việc vì mua đồ IBM cả" và dù biết có nhiều giải pháp đơn giản và tối ưu hơn nhưng [**Docker**](/container/docker.md) vẫn là một thứ nên biết để phục vụ thị trường. [**Kubernetes**](/container/k8s.md) là một vấn đề mà Google tạo ra cho thế giới để họ có thể kinh doanh giải pháp của mình (GKE), nhưng vì nó cũng là thứ đang phổ biến nên bạn sẽ phải động tới nó ở một lúc nào đó khi theo cái ngành này.
8. Học cách tự cài đặt một số thứ như: Web server (Nginx hoặc Apache), Firewall, Forward/Reverse Proxy, Caching server.
9. Configuration Management **Ansible**
10. [**CI/CD**](/cicd/index.md) Tool **GitLab CI** **Github Actions** hoặc **Jenkins**
11. Secret Management như **Vault** hay sử dụng của Kubernetes hoặc Cloud
12. Monitoring (**Grafana**, **Prometheus**, **New Relic**, **Open Telemetry**)
13. Log Management: **Loki**, **Splunk**
14. Artifact Management: **Jfrog** hoặc sử dụng của Cloud.
15. Việc áp dụng **GitOps** sẽ khiến cho team dev nhìn mặt bạn một cách khó hiểu và bắt đầu hỏi những câu như "Tại sao luồng cũ đang chạy đơn giản và bình thường mà sao lại phải thêm thằng này vào?". Sau khi mất một thời gian giải thích về nó thì bạn có thể sử dụng tool như [**ArgoCD**](/git/argocd.md) hoặc **Flux CD**. Tuy nó không thật sự giúp cho cuộc đời bạn tốt hơn hay thậm chí còn làm cuộc đời bạn phức tạp hơn, nhưng ít ra giờ resource trong K8S có thể được quản lý tập trung trên Git.
16. Cloud Design Patterns như **Availability**.

Tất nhiên không ai học hết được đống trên, chỉ cần biết qua và chuyên sâu một cái thôi là được rồi. Không ai đa năng tới mức nắm được hết đống trên đâu nên đừng kỳ vọng.
